name: Preview (Web)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, edited]
  workflow_dispatch:
    inputs:
      pr:
        description: "PR number to upsert (manual run)"
        required: true

permissions:
  contents: read
  pull-requests: write

# Ensure only the latest run per PR is active
concurrency:
  group: preview-web-${{ github.event.pull_request.number || github.event.inputs.pr || github.ref }}
  cancel-in-progress: true

jobs:
  upsert:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    env:
      RENDER_API_SERVICE_ID: ${{ secrets.RENDER_API_SERVICE_ID }}
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Resolve PR number
        run: |
          PR="${{ github.event.pull_request.number }}"
          if [ -z "$PR" ]; then PR="${{ github.event.inputs.pr }}"; fi
          echo "PR=$PR" >> $GITHUB_ENV

      - name: Set deterministic preview URLs
        env:
          WEB_PREFIX: ${{ secrets.RENDER_WEB_HOST_PREFIX }}   # e.g. sniffr-web-ui
          API_PREFIX: ${{ secrets.RENDER_API_HOST_PREFIX }}   # e.g. sniffr-staging
        run: |
          : "${WEB_PREFIX:?Set secret RENDER_WEB_HOST_PREFIX}"
          # Compute locally, write files, then export for *later* steps.
          WEB="https://${WEB_PREFIX}-pr-${PR}.onrender.com"
          echo "$WEB" > web_url.txt
          echo "WEB_URL=$WEB" >> $GITHUB_ENV
          if [ -n "${API_PREFIX:-}" ]; then
            API="https://${API_PREFIX}-pr-${PR}.onrender.com"
            echo "$API" > api_url.txt
            echo "API_URL=$API" >> $GITHUB_ENV
          fi
          echo "deterministic WEB=$WEB"
          [ -n "${API:-}" ] && echo "deterministic API=$API" || true

      # Try Render API discovery to override (short timeout)
      - name: Try Render API discovery (web)
        if: ${{ github.head_ref != '' }}
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ secrets.RENDER_WEB_SERVICE_ID }}
          BRANCH: ${{ github.head_ref }}
          PR_NUMBER: ${{ env.PR }}
          WAIT_SECS: 120
        run: |
          node ./scripts/render-get-preview-url.mjs > _web.txt || true
          if [ -s _web.txt ]; then mv _web.txt web_url.txt; fi

      - name: Try Render API discovery (api)
        if: ${{ github.head_ref != '' && env.RENDER_API_SERVICE_ID != '' }}
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_ID: ${{ env.RENDER_API_SERVICE_ID }}
          BRANCH: ${{ github.head_ref }}
          PR_NUMBER: ${{ env.PR }}
          WAIT_SECS: 120
        run: |
          node ./scripts/render-get-preview-url.mjs > _api.txt || true
          if [ -s _api.txt ]; then mv _api.txt api_url.txt; fi

      - name: Show resolved preview URLs
        run: |
          echo "WEB=$(cat web_url.txt 2>/dev/null || echo '')"
          echo "API=$(cat api_url.txt 2>/dev/null || echo '')"

      # üîí Print non-secret evidence and fail if API & WEB prefixes are identical
      - name: Show safe hosts + guard API‚â†WEB
        run: |
          set -e
          web=$(cat web_url.txt 2>/dev/null || echo '')
          api=$(cat api_url.txt 2>/dev/null || echo '')

          web_host=${web#https://}
          api_host=${api#https://}

          web_suffix=${web_host#*-}
          api_suffix=${api_host#*-}

          web_prefix=${web_host%%-pr-*}
          api_prefix=${api_host%%-pr-*}

          web_hash=$(printf %s "$web_prefix" | sha1sum | cut -c1-8)
          api_hash=$(printf %s "$api_prefix" | sha1sum | cut -c1-8)

          echo "WEB suffix: $web_suffix"
          echo "API suffix: $api_suffix"
          echo "WEB prefix hash: $web_hash"
          echo "API prefix hash: $api_hash"

          if [ -n "$api" ] && [ "$web_prefix" = "$api_prefix" ]; then
            echo "‚ùå API and WEB prefixes are IDENTICAL (hash=$web_hash). Check RENDER_*_HOST_PREFIX secrets."; exit 1
          fi
          echo "‚úÖ API and WEB prefixes differ."

      - name: Upsert pretty URL (available origins only)
        env:
          WORKER_WEBHOOK: ${{ secrets.PR_WORKER_URL }}   # e.g. https://render-pr-alias.<user>.workers.dev
          WORKER_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          set -e
          web=$(cat web_url.txt 2>/dev/null || true)
          api=$(cat api_url.txt 2>/dev/null || true)
          if [ -z "$web" ] && [ -z "$api" ]; then
            echo "No Render preview URLs found"; exit 1; fi
          prefixes='["/api","/rapi-doc","/docs"]'
          payload=$(jq -n \
            --arg pr  "$PR" \
            --arg api "$api" \
            --arg web "$web" \
            --argjson prefixes "$prefixes" '
            {action:"upsert", pr: ($pr|tonumber)}
              + (if ($api|length) > 0 then {api:$api} else {} end)
              + (if ($web|length) > 0 then {web:$web} else {} end)
              + { apiPrefixes: $prefixes }')
          echo "::group::Upsert payload"; echo "$payload"; echo "::endgroup::"
          curl -v -w "
          status=%{http_code}
          " -fsSL -X POST "$WORKER_WEBHOOK/_control" \
            -H "x-webhook-secret: $WORKER_SECRET" \
            -H 'content-type: application/json' \
            --data "$payload"

      - name: Verify KV mapping for this PR
        env:
          WORKER_WEBHOOK: ${{ secrets.PR_WORKER_URL }}
          WORKER_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          set -e
          # Try public GET first (ok to fail)
          code=$(curl -sS -o kv.json -w "%{http_code}" "$WORKER_WEBHOOK/kv?pr=${PR}" || true)
          if [ "$code" != "200" ]; then
            # Fallback: ask the control API for the record
            echo "{\"action\":\"get\",\"pr\":${PR}}" > body.json
            curl -fsSL -X POST "$WORKER_WEBHOOK/_control" \
              -H "x-webhook-secret: $WORKER_SECRET" \
              -H "content-type: application/json" \
              --data @body.json > kv.json
          fi
          cat kv.json
          # Normalize both possible shapes: {value:{...}} or {rec:{...}} or flat
          pretty=$(jq -r '(.value.prettyHost // .prettyHost // empty)' kv.json)
          api=$(jq -r '(.value.apiOrigin // .value.api // .rec.api // .api // empty)' kv.json)
          web=$(jq -r '(.value.webOrigin // .value.web // .rec.web // .web // empty)' kv.json)
          # Compute pretty host if not returned
          if [ -z "$pretty" ]; then pretty="pr-${PR}-stage.previews.sniffrpack.com"; fi
          if [ -z "$api" ] && [ -z "$web" ]; then
            echo "‚ùå No api/web in record"; exit 1
          fi
          same=$(jq -r '(.value // .rec // .) as $r | ($r.apiOrigin // $r.api // "") as $a | ($r.webOrigin // $r.web // "") as $w | if ($a != "" and $w != "" and $a == $w) then "yes" else "no" end' kv.json)
          if [ "$same" = "yes" ]; then
            echo "‚ùå KV shows identical api/web origins. Fix prefixes or Render mappings."; exit 1
          fi
          echo "‚úÖ KV looks good: $pretty (api=$api, web=$web)"

      - name: Sanity: /rapi-doc should come from API origin
        run: |
          set -e
          pretty="https://pr-${PR}-stage.previews.sniffrpack.com/rapi-doc/rapidoc.html"
          code=$(curl -s -o /dev/null -w "%{http_code}" "$pretty" || true)
          echo "RapiDoc HTTP $code at $pretty"
          if [ "$code" -ne 200 ]; then
            echo "‚ùå RapiDoc not reachable via pretty URL"; exit 1
          fi

  cleanup:
    if: github.event.action == 'closed' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Resolve PR number
        run: |
          PR="${{ github.event.pull_request.number }}"
          echo "PR=$PR" >> $GITHUB_ENV
      - name: Delete mapping on close
        env:
          WORKER_WEBHOOK: ${{ secrets.PR_WORKER_URL }}
          WORKER_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          curl -fsSL -X POST "$WORKER_WEBHOOK/_control" \
            -H "x-webhook-secret: $WORKER_SECRET" \
            -H 'content-type: application/json' \
            --data "{\"action\":\"delete\",\"pr\":$PR}"
