name: agent

on:
  issues:
    types: [opened, edited, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      title:
        description: "Issue title (optional when dispatching)"
        required: false
        default: ""
      body:
        description: "Issue body (optional when dispatching)"
        required: false
        default: ""

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  AGENT_MODEL: gpt-5

jobs:
  agent:
    runs-on: ubuntu-24.04
    timeout-minutes: 30

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x

      # ------------------------------------------------------------------
      # Gate: decide if we should run, and extract cmd (plan/apply)
      # Accepts "/agent" followed by space OR newline (defaults to plan)
      # ------------------------------------------------------------------
      - name: Gate (should we run?)
        id: gate
        shell: bash
        run: |
          set -euo pipefail
          echo "event=${GITHUB_EVENT_NAME}"
          if [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
            BODY='${{ github.event.comment.body }}'
          elif [[ "${GITHUB_EVENT_NAME}" == "issues" ]]; then
            BODY='${{ github.event.issue.body }}'
          else
            # workflow_dispatch path uses inputs below; still allow /agent via body if present
            BODY="${{ github.event.inputs.body }}"
          fi
          printf 'body: %q\n' "$BODY"

          CLEAN="$(printf '%s' "$BODY" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+/ /g')"

          if echo "$CLEAN" | grep -Ei '^/(agent)\b' >/dev/null; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            CMD="$(printf '%s' "$CLEAN" | awk '{print $2}')"
            [[ -z "$CMD" ]] && CMD="plan"
            echo "cmd=$CMD" >> "$GITHUB_OUTPUT"
          else
            # Allow workflow_dispatch even without /agent
            if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
              echo "ok=true" >> "$GITHUB_OUTPUT"
              echo "cmd=plan" >> "$GITHUB_OUTPUT"
            else
              echo "ok=false" >> "$GITHUB_OUTPUT"
            fi
          fi

      # ------------------------------------------------------------------
      # Your original parser that builds REQUEST_TEXT (kept intact)
      # ------------------------------------------------------------------
      - name: Parse event/title/body into request text
        id: parse
        if: steps.gate.outputs.ok == 'true'
        shell: bash
        env:
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY:  ${{ github.event.issue.body }}
          INPUT_TITLE: ${{ github.event.inputs.title }}
          INPUT_BODY:  ${{ github.event.inputs.body }}
        run: |
          set -euo pipefail

          if [[ "${GITHUB_EVENT_NAME}" == "issues" || "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
            TITLE="${ISSUE_TITLE:-}"
            BODY="${ISSUE_BODY:-}"
            if [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
              BODY='${{ github.event.comment.body }}'
            fi
          else
            TITLE="${INPUT_TITLE:-}"
            BODY="${INPUT_BODY:-}"
          fi

          if [[ -z "${BODY}" ]]; then
            read -r -d '' BODY <<'EOF'
          /agent plan

          # Feature
          Example body to avoid shell expansion.
          EOF
          fi

          CMD=""
          if [[ "${BODY}" =~ ^/[Aa]gent[[:space:]]+([A-Za-z]+) ]]; then
            CMD="${BASH_REMATCH[1],,}"
          fi
          [[ -z "$CMD" ]] && CMD="${{ steps.gate.outputs.cmd }}"

          AFTER="$(printf '%s' "${BODY}" | sed -E 's#^/[Aa]gent[[:space:]]+[A-Za-z]+[[:space:]]*##')"
          if [[ -z "${AFTER}" ]]; then
            MSG="${TITLE} — ${BODY}"
          else
            MSG="${AFTER}"
          fi

          {
            echo "cmd=${CMD}"
            echo 'text<<EOF'
            printf '%s\n' "${MSG}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Install dependencies
        if: steps.gate.outputs.ok == 'true'
        run: npm ci || npm install

      # === Hybrid search context: build → serve → fetch ===
      - name: Build code index (embeddings if key present)
        if: steps.gate.outputs.ok == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: npx tsx tools/build-index.ts

      - name: Install ripgrep (optional)
        if: steps.gate.outputs.ok == 'true'
        run: sudo apt-get update && sudo apt-get install -y ripgrep

      - name: Start search server (background)
        if: steps.gate.outputs.ok == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: npx tsx tools/search-server.ts & echo $! > search.pid

      - name: Fetch harvested context for this request
        if: steps.gate.outputs.ok == 'true'
        env:
          REQUEST_TEXT: ${{ steps.parse.outputs.text }}
        run: node tools/fetch-context.mjs

      - name: Show harvested context size
        if: steps.gate.outputs.ok == 'true'
        run: |
          sudo apt-get update >/dev/null && sudo apt-get install -y jq >/dev/null
          echo "hits: $(jq '.hits | length' .github/agent/.context.json)"

      - name: Run agent (and persist output)
        if: steps.gate.outputs.ok == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GH_TOKEN:       ${{ secrets.GITHUB_TOKEN }}
          MODE:           ${{ steps.parse.outputs.cmd }}
          REQUEST_TEXT:   ${{ steps.parse.outputs.text }}
          AGENT_MODEL:    ${{ env.AGENT_MODEL }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/agent
          echo "MODE=$MODE"
          echo "Text length: $(printf '%s' "$REQUEST_TEXT" | wc -c)"

          if [[ "$MODE" = "plan" ]]; then
            printf '%s' "$REQUEST_TEXT" \
              | node .github/agent/agent.mjs --mode=plan \
              | tee .github/agent/.plan.md
          else
            printf '%s' "$REQUEST_TEXT" \
              | node .github/agent/agent.mjs --mode=apply \
              | tee .github/agent/.apply.json
          fi

      # ---------------------------
      # Plan Lint (quality gate)
      # ---------------------------
      - name: Plan Lint (quality gate)
        id: lint1
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'plan'
        run: |
          set -euo pipefail
          # capture both stdout and stderr so we can show the user exactly what failed
          node .github/agent/plan-lint.mjs .github/agent/PLAN.json 2>&1 | tee .github/agent/.lint.txt
        continue-on-error: true

      - name: Auto-refine plan from lint feedback (1 attempt)
        id: refine
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'plan' && steps.lint1.outcome == 'failure'
        shell: bash
        env:
          REQUEST_TEXT: ${{ steps.parse.outputs.text }}
        run: |
          set -euo pipefail
          # Build a refinement prompt that includes lint failures + the original request text
          {
            echo "/agent plan"
            echo
            echo "## Please revise the plan to satisfy the linter. Only produce a valid PLAN with PLAN.json as per contract."
            echo
            echo "### Lint failures"
            echo '```'
            sed -E 's/\x1b\[[0-9;]*m//g' .github/agent/.lint.txt
            echo '```'
            echo
            echo "### Original request"
            echo '```'
            printf '%s\n' "$REQUEST_TEXT"
            echo '```'
          } > .github/agent/REFINED_REQUEST.md

          # Re-run plan using the refined prompt; agent.mjs will write .plan.md and PLAN.json
          cat .github/agent/REFINED_REQUEST.md \
            | node .github/agent/agent.mjs --mode=plan \
            | tee .github/agent/.plan.md

      - name: Plan Lint (after refine)
        id: lint2
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'plan' && steps.lint1.outcome == 'failure'
        run: |
          set -euo pipefail
          node .github/agent/plan-lint.mjs .github/agent/PLAN.json 2>&1 | tee .github/agent/.lint2.txt
        continue-on-error: true

      - name: Comment lint results
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'plan'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            function read(p){ try { return fs.readFileSync(p,'utf8'); } catch { return ''; } }
            const l1 = read('.github/agent/.lint.txt');
            const l2 = read('.github/agent/.lint2.txt');
            const refined = Boolean(l2.trim());
            const body = [
              '### Plan Lint Results',
              '',
              refined ? '**Initial lint:**' : '**Lint:**',
              '```',
              (l1 || '(no output)'),
              '```',
              refined ? '**After auto-refine:**' : '',
              refined ? '```' : '',
              refined ? (l2 || '(no output)') : '',
              refined ? '```' : '',
              '_The agent will not open a PR until the plan passes the linter._'
            ].filter(Boolean).join('\n');
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body
            });


      - name: Comment plan preview
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'plan'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const p = '.github/agent/.plan.md';
            if (!fs.existsSync(p)) { core.info('No plan file at ' + p); return; }
            const md = fs.readFileSync(p, 'utf8');
            const short = md.replace(/\s+/g, ' ').trim().slice(0, 151);
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: ['**Agent plan (preview)**','', short + (md.length > 151 ? '…' : ''), '', '_Full plan attached as artifact `agent-plan`._'].join('\n')
            });

      - name: Upload full plan as artifact
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'plan'
        uses: actions/upload-artifact@v4
        with:
          name: agent-plan
          path: .github/agent/.plan.md
          include-hidden-files: true
          if-no-files-found: warn

      - name: Link to this run (comment)
        if: steps.gate.outputs.ok == 'true' && (github.event_name == 'issues' || github.event_name == 'issue_comment')
        uses: actions/github-script@v7
        with:
          script: |
            const url = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }}`;
            await github.rest.issues.createComment({ ...context.repo, issue_number: context.issue.number, body: `Artifact **agent-plan** is attached to this run.\n\n${url}` });

      - name: Materialize files from APPLY JSON
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'apply'
        shell: bash
        run: |
          set -euo pipefail
          node -e "const fs=require('fs'),p=require('path');const j=JSON.parse(fs.readFileSync('.github/agent/.apply.json','utf8'));if(!j.files||!j.files.length){process.exit(0)};for(const f of j.files){fs.mkdirSync(p.dirname(f.path),{recursive:true});fs.writeFileSync(f.path,f.contents,'utf8');}fs.writeFileSync('.github/agent/.commitmsg', (j.commitMessage||'chore: agent apply')+'\n');fs.writeFileSync('.github/agent/.summary', j.summary||'');"

      - name: Read APPLY metadata
        id: applymeta
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'apply'
        run: |
          echo "commit<<EOF" >> $GITHUB_OUTPUT
          jq -r '.commitMessage // "chore: agent apply"' .github/agent/.apply.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          jq -r '.summary // ""' .github/agent/.apply.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request (agent apply)
        if: steps.gate.outputs.ok == 'true' && steps.parse.outputs.cmd == 'apply'
        uses: peter-evans/create-pull-request@v6
        with:
          branch: agent/apply-${{ github.run_id }}
          title: ${{ steps.applymeta.outputs.commit }}
          commit-message: ${{ steps.applymeta.outputs.commit }}
          body: |
            ${{ steps.applymeta.outputs.summary }}

            _Auto-generated by **agent** from issue #${{ github.event.issue.number }}._
          labels: agent, automated-pr
          base: main
